use anyhow::Result;
use comelit_hub_rs::{DeviceStatus, DoorbellDeviceData};
use futures_util::lock::Mutex;
use hap::{
    HapType,
    accessory::{AccessoryInformation, HapAccessory},
    characteristic::HapCharacteristic,
    server::{IpServer, Server},
    service::{
        HapService, accessory_information::AccessoryInformationService, doorbell::DoorbellService,
        switch::SwitchService,
    },
};
use serde_json::Value;
use std::sync::Arc;
use tokio::time::sleep;
use tracing::info;

use crate::accessories::ComelitAccessory;

// this file is auto-generated by hap-codegen

use serde::ser::{Serialize, SerializeStruct, Serializer};

/// Stateless Programmable Switch accessory.
#[derive(Debug, Default)]
pub struct DoorbellAccessory {
    /// ID of the Stateless Programmable Switch accessory.
    id: u64,

    /// Accessory Information service.
    pub accessory_information: AccessoryInformationService,
    /// Doorbell service.
    pub doorbell: DoorbellService,
    /// Switch service.
    pub switch: SwitchService,
}

impl DoorbellAccessory {
    /// Creates a new Stateless Programmable Switch accessory.
    pub fn new(id: u64, information: AccessoryInformation) -> Result<Self> {
        let accessory_information = information.to_service(1, id)?;
        let access_info_id = accessory_information.get_characteristics().len() as u64;
        let mut doorbell = DoorbellService::new(1 + access_info_id + 1, id);
        doorbell.set_hidden(true);
        doorbell.set_primary(true);
        let doorbell_id = doorbell.get_characteristics().len() as u64;
        let mut switch = SwitchService::new(1 + access_info_id + doorbell_id + 1, id);
        switch.set_primary(true);

        Ok(Self {
            id,
            accessory_information,
            doorbell,
            switch,
        })
    }
}

impl HapAccessory for DoorbellAccessory {
    fn get_id(&self) -> u64 {
        self.id
    }

    fn set_id(&mut self, id: u64) {
        self.id = id;
    }

    fn get_service(&self, hap_type: HapType) -> Option<&dyn HapService> {
        self.get_services()
            .into_iter()
            .find(|&service| service.get_type() == hap_type)
            .map(|v| v as _)
    }

    fn get_mut_service(&mut self, hap_type: HapType) -> Option<&mut dyn HapService> {
        self.get_mut_services()
            .into_iter()
            .find(|service| service.get_type() == hap_type)
            .map(|v| v as _)
    }

    fn get_services(&self) -> Vec<&dyn HapService> {
        vec![&self.accessory_information, &self.doorbell, &self.switch]
    }

    fn get_mut_services(&mut self) -> Vec<&mut dyn HapService> {
        vec![
            &mut self.accessory_information,
            &mut self.doorbell,
            &mut self.switch,
        ]
    }
}

impl Serialize for DoorbellAccessory {
    fn serialize<S: Serializer>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error> {
        let mut state = serializer.serialize_struct("HapAccessory", 2)?;
        state.serialize_field("aid", &self.get_id())?;
        state.serialize_field("services", &self.get_services())?;
        state.end()
    }
}

pub(crate) struct ComelitDoorbellAccessory {
    pub(crate) id: String,
    pub(crate) accessory_pointer: Arc<Mutex<Box<dyn HapAccessory + 'static>>>,
}

impl ComelitDoorbellAccessory {
    pub(crate) async fn new(
        id: u64,
        door_data: &DoorbellDeviceData,
        server: &IpServer,
    ) -> Result<Self> {
        let device_id = door_data.id.clone();
        let name = door_data.description.clone().unwrap_or(device_id.clone());
        let mut doorbell_accessory = DoorbellAccessory::new(
            id,
            AccessoryInformation {
                name: name.clone(),
                model: "VIP Doorbell".to_string(),
                manufacturer: "Comelit".to_string(),
                serial_number: device_id.clone(),
                ..Default::default()
            },
        )?;

        doorbell_accessory.doorbell.brightness = None;
        doorbell_accessory.doorbell.mute = None;
        doorbell_accessory.doorbell.operating_state_response = None;
        doorbell_accessory.doorbell.volume = None;

        doorbell_accessory
            .doorbell
            .programmable_switch_event
            .set_event_notifications(Some(true));

        let accessory_pointer = server.add_accessory(doorbell_accessory).await?;
        Ok(Self {
            id: device_id,
            accessory_pointer,
        })
    }
}

impl ComelitAccessory<DoorbellDeviceData> for ComelitDoorbellAccessory {
    fn get_comelit_id(&self) -> &str {
        &self.id
    }

    async fn update(&mut self, data: &DoorbellDeviceData) -> Result<()> {
        if data.status.clone().unwrap_or_default() == DeviceStatus::On {
            {
                info!("Doorbell {} just triggered!", self.id);
                let mut accessory = self.accessory_pointer.lock().await;
                let service = accessory.get_mut_service(HapType::Doorbell).unwrap();
                let programmable_switch = service
                    .get_mut_characteristic(HapType::StatefulProgrammableSwitch)
                    .unwrap();
                programmable_switch.set_value(Value::from(2)).await?; // long press
                let switch = accessory.get_mut_service(HapType::Switch).unwrap();
                let power_state = switch.get_mut_characteristic(HapType::PowerState).unwrap();
                power_state.set_value(Value::from(true)).await?;
            } // drop the lock
            let accessory_pointer = self.accessory_pointer.clone();
            tokio::spawn(async move {
                sleep(std::time::Duration::from_secs(2)).await;
                let mut accessory = accessory_pointer.lock().await;
                let switch = accessory.get_mut_service(HapType::Switch).unwrap();
                let power_state = switch.get_mut_characteristic(HapType::PowerState).unwrap();
                power_state.set_value(Value::from(false)).await.unwrap();
            });
        }
        Ok(())
    }
}
