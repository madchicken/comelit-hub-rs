use std::sync::Arc;

use anyhow::Result;
use comelit_client_rs::DoorbellDeviceData;
use futures::FutureExt;
use hap::{
    HapType,
    accessory::{AccessoryInformation, HapAccessory},
    characteristic::{AsyncCharacteristicCallbacks, HapCharacteristic},
    pointer::Accessory,
    server::{IpServer, Server},
    service::{
        HapService, accessory_information::AccessoryInformationService, doorbell::DoorbellService,
        switch::SwitchService,
    },
};
use serde_json::Value;
use tokio::{sync::Mutex, time::sleep};
use tracing::info;

use crate::accessories::ComelitAccessory;

// this file is auto-generated by hap-codegen

use serde::ser::{Serialize, SerializeStruct, Serializer};

/// Stateless Programmable Switch accessory.
#[derive(Debug, Default)]
pub struct DoorbellAccessory {
    /// ID of the Stateless Programmable Switch accessory.
    id: u64,

    /// Accessory Information service.
    pub accessory_information: AccessoryInformationService,
    /// Doorbell service.
    pub doorbell: DoorbellService,
    /// Switch service.
    pub switch: SwitchService,
}

impl DoorbellAccessory {
    /// Creates a new Stateless Programmable Switch accessory.
    pub fn new(id: u64, information: AccessoryInformation) -> Result<Self> {
        let accessory_information = information.to_service(1, id)?;
        let access_info_id = accessory_information.get_characteristics().len() as u64;
        let mut doorbell = DoorbellService::new(1 + access_info_id + 1, id);
        doorbell.set_hidden(true);
        doorbell.set_primary(true);
        let doorbell_id = doorbell.get_characteristics().len() as u64;
        let mut switch = SwitchService::new(1 + access_info_id + doorbell_id + 1, id);
        switch.set_primary(true);

        Ok(Self {
            id,
            accessory_information,
            doorbell,
            switch,
        })
    }
}

impl HapAccessory for DoorbellAccessory {
    fn get_id(&self) -> u64 {
        self.id
    }

    fn set_id(&mut self, id: u64) {
        self.id = id;
    }

    fn get_service(&self, hap_type: HapType) -> Option<&dyn HapService> {
        self.get_services()
            .into_iter()
            .find(|&service| service.get_type() == hap_type)
            .map(|v| v as _)
    }

    fn get_mut_service(&mut self, hap_type: HapType) -> Option<&mut dyn HapService> {
        self.get_mut_services()
            .into_iter()
            .find(|service| service.get_type() == hap_type)
            .map(|v| v as _)
    }

    fn get_services(&self) -> Vec<&dyn HapService> {
        vec![&self.accessory_information, &self.doorbell, &self.switch]
    }

    fn get_mut_services(&mut self) -> Vec<&mut dyn HapService> {
        vec![
            &mut self.accessory_information,
            &mut self.doorbell,
            &mut self.switch,
        ]
    }
}

impl Serialize for DoorbellAccessory {
    fn serialize<S: Serializer>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error> {
        let mut state = serializer.serialize_struct("HapAccessory", 2)?;
        state.serialize_field("aid", &self.get_id())?;
        state.serialize_field("services", &self.get_services())?;
        state.end()
    }
}

struct State {
    pressed: bool,
    accessory: Option<Accessory>,
}

pub(crate) struct ComelitDoorbellAccessory {
    pub(crate) id: String,
    pub(crate) accessory: Accessory,
    state: Arc<Mutex<State>>,
}

impl ComelitDoorbellAccessory {
    pub(crate) async fn new(
        id: u64,
        door_data: &DoorbellDeviceData,
        server: &IpServer,
    ) -> Result<Self> {
        let device_id = door_data.id.clone();
        let name = door_data.description.clone().unwrap_or(device_id.clone());
        let mut doorbell_accessory = DoorbellAccessory::new(
            id,
            AccessoryInformation {
                name: name.clone(),
                model: "VIP Doorbell".to_string(),
                manufacturer: "Comelit".to_string(),
                serial_number: device_id.clone(),
                ..Default::default()
            },
        )?;

        doorbell_accessory.doorbell.brightness = None;
        doorbell_accessory.doorbell.mute = None;
        doorbell_accessory.doorbell.operating_state_response = None;
        doorbell_accessory.doorbell.volume = None;

        doorbell_accessory
            .doorbell
            .programmable_switch_event
            .set_event_notifications(Some(true));

        let state = Arc::new(Mutex::new(State {
            pressed: false,
            accessory: None,
        }));
        let _state = state.clone();
        doorbell_accessory
            .switch
            .power_state
            .on_read_async(Some(move || {
                let state = _state.clone();
                async move {
                    let s = state.lock().await.pressed;
                    Ok(Some(s))
                }
                .boxed()
            }));

        let _state = state.clone();
        let _id = device_id.clone();
        doorbell_accessory.switch.power_state.on_update_async(Some(
            move |_old_state, new_state| {
                let state = _state.clone();
                let _id = _id.clone();
                async move {
                    if new_state {
                        // Handle power state update here
                        let state = state.clone();
                        if let Ok(mut _state) = state.try_lock()
                            && let Some(_accessory) = _state.accessory.clone().as_ref()
                        {
                            info!("Doorbell pressed");
                            _state.pressed = true;
                            ring(_id.as_str(), _accessory.clone(), state.clone()).await?;
                        }
                    }
                    Ok(())
                }
                .boxed()
            },
        ));

        let accessory = server.add_accessory(doorbell_accessory).await?;
        state.lock().await.accessory = Some(accessory.clone());

        Ok(Self {
            id: device_id,
            accessory,
            state,
        })
    }
}

async fn ring(
    id: &str,
    accessory: Accessory,
    state: Arc<Mutex<State>>,
) -> Result<(), anyhow::Error> {
    {
        info!("Doorbell {} just triggered!", id);
        let mut accessory = accessory.lock().await;
        let service = accessory.get_mut_service(HapType::Doorbell).unwrap();
        let programmable_switch = service
            .get_mut_characteristic(HapType::ProgrammableSwitchEvent)
            .unwrap();
        programmable_switch.update_value(Value::from(1)).await?; // single press (doorbell ring)
        let switch = accessory.get_mut_service(HapType::Switch).unwrap();
        let power_state = switch.get_mut_characteristic(HapType::PowerState).unwrap();
        power_state.update_value(Value::from(true)).await?;
    }
    let accessory_pointer = accessory.clone();
    let state = state.clone();
    tokio::spawn(async move {
        sleep(std::time::Duration::from_secs(2)).await;
        let mut accessory = accessory_pointer.lock().await;
        let switch = accessory.get_mut_service(HapType::Switch).unwrap();
        let power_state = switch.get_mut_characteristic(HapType::PowerState).unwrap();
        power_state.update_value(Value::from(false)).await.unwrap();
        if let Ok(mut state) = state.try_lock() {
            state.pressed = false;
        }
    });
    Ok(())
}

impl ComelitAccessory<DoorbellDeviceData> for ComelitDoorbellAccessory {
    fn get_comelit_id(&self) -> &str {
        &self.id
    }

    async fn update(&mut self, data: &DoorbellDeviceData) -> Result<()> {
        ring(data.id.as_str(), self.accessory.clone(), self.state.clone()).await?;
        Ok(())
    }
}
